// Code generated by go-swagger; DO NOT EDIT.

package restapi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/Stratoscale/swagger/query"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"

	"github.com/stevexnicholls/next/restapi/operations"
	"github.com/stevexnicholls/next/restapi/operations/backup"
	"github.com/stevexnicholls/next/restapi/operations/health"
	"github.com/stevexnicholls/next/restapi/operations/kv"

	models "github.com/stevexnicholls/next/models"
)

type contextKey string

const AuthKey contextKey = "Auth"

//go:generate mockery -name BackupAPI -inpkg

// BackupAPI
type BackupAPI interface {
	BackupGet(ctx context.Context, params backup.BackupGetParams) middleware.Responder
}

//go:generate mockery -name HealthAPI -inpkg

// HealthAPI
type HealthAPI interface {
	// HealthGet is get service health
	HealthGet(ctx context.Context, params health.HealthGetParams) middleware.Responder
}

//go:generate mockery -name KvAPI -inpkg

// KvAPI
type KvAPI interface {
	KeyDelete(ctx context.Context, params kv.KeyDeleteParams) middleware.Responder
	// KeyList is Lists all the keys
	KeyList(ctx context.Context, params kv.KeyListParams) middleware.Responder
	ValueGet(ctx context.Context, params kv.ValueGetParams) middleware.Responder
	ValueUpdate(ctx context.Context, params kv.ValueUpdateParams) middleware.Responder
}

// Config is configuration for Handler
type Config struct {
	BackupAPI
	HealthAPI
	KvAPI
	Logger func(string, ...interface{})
	// InnerMiddleware is for the handler executors. These do not apply to the swagger.json document.
	// The middleware executes after routing but before authentication, binding and validation
	InnerMiddleware func(http.Handler) http.Handler

	// Authorizer is used to authorize a request after the Auth function was called using the "Auth*" functions
	// and the principal was stored in the context in the "AuthKey" context value.
	Authorizer func(*http.Request) error

	// AuthToken Applies when the "x-api-key" header is set
	AuthToken func(token string) (interface{}, error)
}

// Handler returns an http.Handler given the handler configuration
// It mounts all the business logic implementers in the right routing.
func Handler(c Config) (http.Handler, error) {
	spec, err := loads.Analyzed(swaggerCopy(SwaggerJSON), "")
	if err != nil {
		return nil, fmt.Errorf("analyze swagger: %v", err)
	}
	api := operations.NewNextAPI(spec)
	api.ServeError = errors.ServeError
	api.Logger = c.Logger

	api.JSONConsumer = runtime.JSONConsumer()
	api.JSONProducer = runtime.JSONProducer()
	api.BinProducer = runtime.ByteStreamProducer()
	api.TokenAuth = func(token string) (interface{}, error) {
		if c.AuthToken == nil {
			return token, nil
		}
		return c.AuthToken(token)
	}

	api.APIAuthorizer = authorizer(c.Authorizer)
	api.BackupBackupGetHandler = backup.BackupGetHandlerFunc(func(params backup.BackupGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.BackupAPI.BackupGet(ctx, params)
	})
	api.HealthHealthGetHandler = health.HealthGetHandlerFunc(func(params health.HealthGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.HealthAPI.HealthGet(ctx, params)
	})
	api.KvKeyDeleteHandler = kv.KeyDeleteHandlerFunc(func(params kv.KeyDeleteParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.KvAPI.KeyDelete(ctx, params)
	})
	api.KvKeyListHandler = kv.KeyListHandlerFunc(func(params kv.KeyListParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.KvAPI.KeyList(ctx, params)
	})
	api.KvValueGetHandler = kv.ValueGetHandlerFunc(func(params kv.ValueGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.KvAPI.ValueGet(ctx, params)
	})
	api.KvValueUpdateHandler = kv.ValueUpdateHandlerFunc(func(params kv.ValueUpdateParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = storeAuth(ctx, principal)
		return c.KvAPI.ValueUpdate(ctx, params)
	})
	api.ServerShutdown = func() {}
	return api.Serve(c.InnerMiddleware), nil
}

// Query parse functions for all the models
// Those can be used to extract database query from the http path's query string
var (
	ErrorQueryParse    = query.MustNewBuilder(&query.Config{Model: models.Error{}}).ParseRequest
	KeyValueQueryParse = query.MustNewBuilder(&query.Config{Model: models.KeyValue{}}).ParseRequest
)

// swaggerCopy copies the swagger json to prevent data races in runtime
func swaggerCopy(orig json.RawMessage) json.RawMessage {
	c := make(json.RawMessage, len(orig))
	copy(c, orig)
	return c
}

// authorizer is a helper function to implement the runtime.Authorizer interface.
type authorizer func(*http.Request) error

func (a authorizer) Authorize(req *http.Request, principal interface{}) error {
	if a == nil {
		return nil
	}
	ctx := storeAuth(req.Context(), principal)
	return a(req.WithContext(ctx))
}

func storeAuth(ctx context.Context, principal interface{}) context.Context {
	return context.WithValue(ctx, AuthKey, principal)
}
